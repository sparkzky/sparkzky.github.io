<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>多线程消息处理系统 | Sparkzky&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.bootcss.com/prism/9000.0.1/themes/prism.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.5.1/katex.min.css">
    <script charset="utf-8" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="true"></script>
    <link rel="icon" type="image/png" href="https://avatars.githubusercontent.com/u/146502758?s=400&amp;u=b8a39089c210f747787383af20846de9556386c8&amp;v=4">
    <meta name="description" content="Nothing to be found">
    
    <link rel="preload" href="/assets/css/0.styles.219b403a.css" as="style"><link rel="preload" href="/assets/js/app.392e1bce.js" as="script"><link rel="preload" href="/assets/js/11.a00298db.js" as="script"><link rel="preload" href="/assets/js/4.6f43f24c.js" as="script"><link rel="preload" href="/assets/js/8.ddba2f81.js" as="script"><link rel="preload" href="/assets/js/23.c2601bd2.js" as="script"><link rel="preload" href="/assets/js/3.91df9f30.js" as="script"><link rel="prefetch" href="/assets/js/10.5dbe98a1.js"><link rel="prefetch" href="/assets/js/12.516ada50.js"><link rel="prefetch" href="/assets/js/13.ed14be29.js"><link rel="prefetch" href="/assets/js/14.1517947c.js"><link rel="prefetch" href="/assets/js/15.5c6a24d4.js"><link rel="prefetch" href="/assets/js/16.b507aa79.js"><link rel="prefetch" href="/assets/js/17.87d50f46.js"><link rel="prefetch" href="/assets/js/18.584f55d9.js"><link rel="prefetch" href="/assets/js/19.56b8692f.js"><link rel="prefetch" href="/assets/js/2.cf254b8a.js"><link rel="prefetch" href="/assets/js/20.a0437c1b.js"><link rel="prefetch" href="/assets/js/21.0099b358.js"><link rel="prefetch" href="/assets/js/22.bfacb966.js"><link rel="prefetch" href="/assets/js/5.7ca9e7a7.js"><link rel="prefetch" href="/assets/js/6.8c5f5d5e.js"><link rel="prefetch" href="/assets/js/7.7f0a3a0f.js"><link rel="prefetch" href="/assets/js/9.83a765f6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.219b403a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="header-wrap" data-v-33920667><div class="header page" data-v-33920667><div class="left" data-v-33920667><div class="motto" data-v-33920667></div> <div class="nav" data-v-33920667></div></div> <div class="right" data-v-33920667><div class="search-box" data-v-33920667><input aria-label="Search" placeholder="" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></div> <div class="page post-page"><div class="title"><div class="post-title">多线程消息处理系统</div></div> <div class="info"><div class="author">sparkzky</div> <div class="date">2025/09/25</div> <div class="count"><span id="busuanzi_value_page_pv"></span> <span>views</span></div></div> <div class="post-content"><div class="content__default"><h1 id="多线程消息处理系统"><a href="#多线程消息处理系统" class="header-anchor">#</a> 多线程消息处理系统</h1> <h2 id="多线程消息处理系统-2"><a href="#多线程消息处理系统-2" class="header-anchor">#</a> 多线程消息处理系统</h2> <p>设计一个多线程消息处理系统（结合消息队列）是一个常见的后端架构模式，它可以有效地解耦服务、异步处理任务、削峰填谷，从而提高系统的整体性能和可伸缩性。</p> <h3 id="一、-核心组件"><a href="#一、-核心组件" class="header-anchor">#</a> 一、 核心组件</h3> <p>一个典型的多线程消息处理系统包含以下几个核心组件：</p> <table><thead><tr><th style="text-align:left;">组件</th> <th style="text-align:left;">描述</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>消息队列 (Message Queue)</strong></td> <td style="text-align:left;">系统的核心，作为生产者和消费者之间的缓冲区，用于存储待处理的消息。它可以是进程内的内存队列，也可以是像 RabbitMQ, Kafka, RocketMQ 这样的外部消息中间件。</td></tr> <tr><td style="text-align:left;"><strong>生产者 (Producer)</strong></td> <td style="text-align:left;">消息的创建者和发送方。生产者将需要异步处理的任务或数据封装成消息，然后发送到消息队列中。</td></tr> <tr><td style="text-align:left;"><strong>消费者 (Consumer)</strong></td> <td style="text-align:left;">消息的处理者。通常会有多个消费者线程从消息队列中获取消息并执行相应的业务逻辑。这些消费者通常由一个线程池来管理。</td></tr> <tr><td style="text-align:left;"><strong>线程池 (Thread Pool)</strong></td> <td style="text-align:left;">管理一组工作线程（消费者），避免了为每个任务都创建和销毁线程的开销，提高了资源利用率和系统响应速度。</td></tr> <tr><td style="text-align:left;"><strong>消息 (Message)</strong></td> <td style="text-align:left;">在生产者和消费者之间传递的数据单元。通常包含任务所需的所有信息。</td></tr></tbody></table> <h3 id="二、-架构设计"><a href="#二、-架构设计" class="header-anchor">#</a> 二、 架构设计</h3> <p>基本的架构模式是<strong>生产者-消费者模式</strong>：</p> <ol><li><strong>生产者</strong>将消息放入一个共享的、线程安全的消息队列中。</li> <li><strong>消费者线程池</strong>中的多个线程并发地从队列中取出消息进行处理。</li></ol> <p>这种设计实现了生产者和消费者的解耦，生产者无需等待消费者处理完成，可以继续处理其他请求，从而提高了系统的吞吐量。</p> <h3 id="三、-实践"><a href="#三、-实践" class="header-anchor">#</a> 三、 实践</h3> <p>在设计和实现多线程消息处理系统时，需要仔细考虑以下几个方面：</p> <h4 id="_1-线程安全"><a href="#_1-线程安全" class="header-anchor">#</a> 1. 线程安全</h4> <ul><li><strong>队列的线程安全</strong>: 必须使用线程安全的消息队列,在多线程环境下的入队和出队操作需要是原子性的。</li></ul> <h4 id="_2-消息的可靠性与确认机制"><a href="#_2-消息的可靠性与确认机制" class="header-anchor">#</a> 2. 消息的可靠性与确认机制</h4> <ul><li><strong>消息确认 (Acknowledgement)</strong>: 为防止消息在处理过程中因消费者崩溃而丢失，应采用消息确认机制。消费者在成功处理完一条消息后，向消息队列发送一个确认回执。如果消息队列没有收到确认，它会认为该消息没有被成功处理，并会将其重新投递给其他消费者。（有点像分布式中的 map/recude 任务的分发，如果超时了就认为没完成就交给其他的节点来运行）
这里或许可以在将消息发送出去的时候将这个消息设置为灰色（通过标志位来让这个消息对于分发器不可见），然后要是发送出去的消息没有收到确认回执的话就恢复这个消息:)</li></ul> <h4 id="_3-错误处理与重试机制"><a href="#_3-错误处理与重试机制" class="header-anchor">#</a> 3. 错误处理与重试机制</h4> <ul><li><strong>处理失败</strong>: 当消费者处理消息失败时，需要有明确的错误处理策略。</li> <li><strong>重试机制</strong>: 可以设置重试次数和重试间隔。对于瞬时性错误，重试几次后可能会成功。</li> <li><strong>死信队列 (Dead-Letter Queue)</strong>: 如果消息经过多次重试后仍然失败，应将其发送到一个特殊的“死信队列”中。 这样可以避免有问题的消息阻塞整个处理流程，并方便后续的人工排查和处理。</li></ul> <h4 id="_4-并发与顺序性"><a href="#_4-并发与顺序性" class="header-anchor">#</a> 4. 并发与顺序性</h4> <ul><li><strong>并发处理</strong>: 多线程消费天然支持并发处理，可以显著提高处理速度。</li> <li><strong>顺序保证</strong>: 在某些业务场景下，需要保证消息的处理顺序（例如，同一个用户的订单操作）。在多线程环境下保证严格的顺序是一个挑战。
<ul><li><strong>解决方案</strong>：
<ul><li><strong>消息分组/分区 (Message Grouping/Partitioning)</strong>: 将需要保证顺序的消息发送到同一个队列或分区中，并确保只有一个消费者线程处理该队列/分区。可以根据业务标识（如 <code>userId</code>, <code>orderId</code>）进行哈希分区。</li> <li><strong>单线程处理</strong>: 如果全局都需要严格的顺序，那就只能使用单线程消费，但这会牺牲并发性。</li></ul></li></ul></li></ul> <h4 id="_5-消费者幂等性"><a href="#_5-消费者幂等性" class="header-anchor">#</a> 5. 消费者幂等性</h4> <ul><li><strong>幂等性设计</strong>: 由于网络问题或消费者故障，消息可能会被重复投递。因此，消费者的处理逻辑必须是幂等的，即多次处理同一条消息和一次处理的结果是完全相同的。
<ul><li><strong>实现方式</strong>:
<ul><li>在数据库中为消息创建一个唯一 ID，并在处理前检查该 ID 是否已被处理。</li> <li>利用数据库的唯一索引约束来防止重复插入。</li></ul></li></ul></li></ul> <h4 id="_6-流量控制与背压-backpressure"><a href="#_6-流量控制与背压-backpressure" class="header-anchor">#</a> 6. 流量控制与背压 (Backpressure)</h4> <ul><li><strong>问题</strong>: 如果生产者的速度远快于消费者的处理速度，消息队列中的消息会不断堆积，最终可能导致内存耗尽。</li> <li><strong>解决方案</strong>:
<ul><li><strong>有界队列 (Bounded Queue)</strong>: 使用有界队列可以限制队列的最大长度。当队列满时，生产者会被阻塞或被拒绝，从而减缓生产速度。</li> <li><strong>监控与告警</strong>: 实时监控消息队列的长度，当超过阈值时进行告警，以便及时扩容消费者或排查处理慢的原因。</li></ul></li></ul> <h4 id="_7-优雅停机"><a href="#_7-优雅停机" class="header-anchor">#</a> 7. 优雅停机</h4> <ul><li>当系统需要关闭或重启时，应确保正在处理的消息和队列中未处理的消息不会丢失。</li> <li><strong>实现方式</strong>:
<ul><li>关闭生产者，不再接收新的消息。（like tcp shutdown）</li> <li>等待消费者线程池处理完当前正在处理的任务以及队列中剩余的任务。</li> <li>设置一个超时时间，如果在规定时间内未能处理完所有消息，可以将未处理的消息持久化，以便系统重启后继续处理。</li></ul></li></ul> <h2 id="消息确认机制"><a href="#消息确认机制" class="header-anchor">#</a> 消息确认机制</h2> <p>消息确认（Message Acknowledgment，简称 Ack）是一种确保消息被消费者成功处理的机制，是保证消息可靠性的核心手段。其基本流程是：消息队列将消息投递给消费者后，会等待消费者的一个回执（即“确认”）。只有收到这个确认，消息队列才会将该消息标记为“已消费”并从队列中（逻辑上或物理上）删除。</p> <p>如果消息队列在一定时间内没有收到消费者的确认，或者收到了一个否定的确认（Nack），它就会认为消费者处理失败。此时，消息队列会根据预设的策略将该消息重新投递给同一个或另一个消费者，以尝试重新处理。</p> <h4 id="如何实现"><a href="#如何实现" class="header-anchor">#</a> <strong>如何实现？</strong></h4> <p>消息确认的实现方式通常分为两种：自动确认和手动确认。主流的消息中间件（如 RabbitMQ, Kafka, RocketMQ）都支持这两种模式。</p> <p><strong>a) 自动确认 (Auto-Ack)</strong></p> <ul><li><strong>工作方式</strong>: 在这种模式下，消息队列的客户端库（消费者端）会在消息被接收后（通常是刚从网络缓冲区读入内存，甚至在业务逻辑处理之前）<strong>自动</strong>向消息队列发送确认。</li> <li><strong>优点</strong>: 实现简单，几乎不需要编写额外的代码。</li> <li><strong>缺点</strong>: <strong>可靠性低</strong>。如果消费者在处理消息的业务逻辑时发生崩溃，由于消息已经被自动确认，消息队列会认为它已成功处理，从而导致消息丢失。因此，这种模式通常只适用于那些允许丢失消息的场景，比如一些非核心的日志记录。</li></ul> <p><strong>b) 手动确认 (Manual-Ack)</strong></p> <p>这是保证消息可靠性的<strong>推荐方式</strong>。</p> <ul><li><p><strong>工作方式</strong>: 消息的控制权完全交给开发者。消费者在接收到消息后，消息队列会暂时锁定该消息（使其对其他消费者不可见）。只有当消费者的业务逻辑<strong>成功执行完毕</strong>后，才由代码显式地调用确认方法，通知消息队列该消息已被成功处理。</p></li> <li><p><strong>优点</strong>: <strong>高可靠性</strong>。可以确保业务逻辑真正执行成功后才确认消息，避免了消息丢失。开发者还可以根据业务处理的结果，决定是确认消息（Ack）还是拒绝消息（Nack）。</p></li> <li><p><strong>缺点</strong>: 实现相对复杂，需要在代码中显式处理确认和异常情况。</p></li> <li><p><strong>实现步骤</strong>:</p> <ol><li>当所有业务逻辑成功完成后，调用 <code>ack()</code> 方法。</li> <li>当处理发生异常时，调用 <code>nack()</code> 或 <code>reject()</code> 方法。你可以选择是否将消息重新放回队列。</li></ol></li></ul> <h2 id="消息队列优化"><a href="#消息队列优化" class="header-anchor">#</a> 消息队列优化</h2> <p>当生产者和消费者的处理能力都超过了消息队列的吞吐能力时，消息队列本身就会成为系统的瓶颈。优化空间主要集中在<strong>提升消息队列自身的处理能力</strong>和<strong>减少不必要的开销</strong>上。</p> <p>以下是一些关键的优化策略：</p> <h4 id="a-对消息队列本身进行扩展-scaling"><a href="#a-对消息队列本身进行扩展-scaling" class="header-anchor">#</a> <strong>a) 对消息队列本身进行扩展 (Scaling)</strong></h4> <ul><li><strong>纵向扩展 (Scale-Up)</strong>: 升级消息队列服务器的硬件，比如使用更快的 CPU、更大的内存、更高性能的磁盘（如 SSD、NVMe）。这是一种简单直接的方式，但成本较高且存在物理上限。</li> <li><strong>横向扩展 (Scale-Out)</strong>: 这是最常用和最有效的方案。通过将消息队列部署成集群模式，将负载分散到多个节点上。几乎所有现代的消息中间件（如 Kafka, RocketMQ, Pulsar）都原生支持高可扩展的集群架构。</li></ul> <h4 id="b-利用分区-主题来并行处理-partitioning"><a href="#b-利用分区-主题来并行处理-partitioning" class="header-anchor">#</a> <strong>b) 利用分区/主题来并行处理 (Partitioning)</strong></h4> <p>这是横向扩展的核心思想。</p> <ul><li><strong>机制</strong>: 将一个主题（Topic）逻辑上拆分成多个分区（Partition）。生产者可以根据一定的策略（如轮询、按 Key 哈希）将消息发送到不同的分区。每个分区可以被一个独立的消费者（或消费者组中的一个消费者）来处理。（后面讲讲哈希环）</li> <li><strong>效果</strong>: 通过增加分区的数量，可以极大地提高消息队列的并行处理能力和整体吞吐量。例如，Kafka 的吞吐量与其分区数量基本上是成正比的。你可以将负载分散到整个集群，而不是压在单个节点上。</li></ul> <h4 id="c-批量处理-batching"><a href="#c-批量处理-batching" class="header-anchor">#</a> <strong>c) 批量处理 (Batching)</strong></h4> <p>网络 I/O 和磁盘 I/O 通常是性能瓶颈所在。批量处理可以显著减少这些操作的次数。</p> <ul><li><strong>生产者批量发送</strong>: 生产者可以将多条消息打包成一个批次（batch）再一次性发送给消息队列，而不是一条一条地发送。这大大减少了网络请求的开销。</li> <li><strong>消费者批量拉取</strong>: 消费者可以一次性从消息队列拉取一批消息进行处理，而不是一次只拉一条。这减少了消费者与消息队列之间的通信次数。</li></ul> <h4 id="d-优化消息本身"><a href="#d-优化消息本身" class="header-anchor">#</a> <strong>d) 优化消息本身</strong></h4> <ul><li><strong>减小消息体积</strong>: 消息越小，网络传输和存储的开销就越低。检查消息体中是否包含不必要的数据。</li> <li><strong>高效的序列化</strong>: 选择性能更高的序列化协议。例如，使用 Protobuf、Avro 通常比使用 JSON、XML 的性能更好，因为它们序列化后的体积更小，解析速度也更快。</li></ul> <h4 id="e-调整持久化策略"><a href="#e-调整持久化策略" class="header-anchor">#</a> <strong>e) 调整持久化策略</strong></h4> <p>消息持久化（将消息写入磁盘）是保证可靠性的关键，但也是性能的主要开销之一。</p> <ul><li><strong>异步刷盘</strong>: 配置消息队列进行异步刷盘，而不是每条消息都同步写入磁盘。这能极大地提升写入性能，但代价是在极端情况下（如操作系统突然断电）可能会丢失少量尚未写入磁盘的数据。需要根据业务对可靠性的要求进行权衡。</li> <li><strong>调整文件系统和磁盘</strong>: 使用为高吞吐量写入优化的文件系统（如 XFS），并确保磁盘 I/O 不是瓶颈。</li></ul> <h4 id="f-调整消息队列的核心参数"><a href="#f-调整消息队列的核心参数" class="header-anchor">#</a> <strong>f) 调整消息队列的核心参数</strong></h4> <ul><li><strong>缓冲区大小 (Buffer Size)</strong>: 调整生产者和消费者端的网络缓冲区、内存缓冲区大小，使其能够容纳更多的消息，从而支持更大规模的批量处理。</li> <li><strong>零拷贝 (Zero-Copy)</strong>: 像 Kafka 这样的系统利用了操作系统的零拷贝技术，数据直接从磁盘文件发送到网络套接字，避免了在内核空间和用户空间之间的多次数据拷贝，极大地提升了数据传输效率。</li></ul> <h4 id="g-架构层面的思考"><a href="#g-架构层面的思考" class="header-anchor">#</a> <strong>g) 架构层面的思考</strong></h4> <ul><li><strong>绕过消息队列？</strong>: 在某些对延迟极其敏感且可以容忍少量数据丢失的场景（如实时监控数据上报），可以考虑使用 UDP 等协议直接通信，或者使用更轻量级的内存队列（如 Redis Pub/Sub），但这牺牲了可靠性。</li> <li><strong>多集群部署</strong>: 对于地理上分散的系统，可以在不同地域部署多个消息队列集群，避免跨地域的长距离网络延迟。</li></ul> <h2 id="哈希环-无锁"><a href="#哈希环-无锁" class="header-anchor">#</a> 哈希环：无锁！</h2> <p>其核心思想是：<strong>通过分区（Partitioning）和线程亲和性（Thread Affinity）来消除共享资源的争用，从而避免使用锁。</strong></p> <p>下面我们来详细拆解这个设计。</p> <h3 id="一、-核心理念-从-争夺-到-分配"><a href="#一、-核心理念-从-争夺-到-分配" class="header-anchor">#</a> 一、 核心理念：从“争夺”到“分配”</h3> <p>传统的多线程模型是“<strong>共享资源 + 锁</strong>”：多个线程去一个共享的中央消息队列（如 <code>BlockingQueue</code>）中争抢任务。这种“争夺”行为必然需要锁来进行仲裁，在高并发下，锁的争用会成为严重的性能瓶颈。</p> <p>无锁模型的核心是转变思路，变为“<strong>任务分配</strong>”：我们不让线程去争抢，而是为每个线程分配一个专属的任务队列。系统有一个前端的<strong>分发器（Dispatcher）</strong>，它负责将收到的消息精准地投递到对应的线程专属队列中。而<strong>哈希环</strong>，就是这个分发器用来决定“这条消息该由哪个线程处理”的核心工具。</p> <h3 id="二、-架构组件"><a href="#二、-架构组件" class="header-anchor">#</a> 二、 架构组件</h3> <ol><li><p><strong>哈希环 (Hash Ring)</strong></p> <ul><li><strong>作用</strong>：提供一种一致性的映射关系，将一个消息的“键（Key）”映射到一个具体的 Worker Thread。</li> <li><strong>工作方式</strong>：我们将每个 Worker Thread 随机（或均匀）地放置在这个环的几个点上。当一个消息进来时，我们取其关键业务标识（如 <code>userId</code>, <code>orderId</code>, <code>sessionId</code>），计算哈希值，这个哈希值也会落在环上的某一点。然后，我们从这个点开始<strong>顺时针</strong>寻找，遇到的第一个 Worker Thread 就是负责处理这条消息的线程。</li></ul></li> <li><p><strong>Worker Threads (消费者)</strong></p> <ul><li>每个线程都是一个独立的处理单元，在启动后就固定不变。</li> <li>关键点：<strong>每个 Worker Thread 拥有一个自己专属的、单消费者（Single-Consumer）的无锁队列</strong>。</li> <li>它永远只从自己的队列里取消息，从不关心其他线程的队列，因此消费端完全没有竞争。</li></ul></li> <li><p><strong>专用无锁队列 (Dedicated Lock-Free Queues)</strong></p> <ul><li>这是实现“无锁”的关键数据结构。每个 Worker Thread 对应一个。</li> <li><strong>特性</strong>：这种队列允许多个生产者（分发器线程）并发地往里写入，但只允许一个消费者（专属的 Worker Thread）从中读取。这种 MPSC (Multiple-Producer, Single-Consumer) 队列是无锁设计的经典模式。</li> <li><strong>实现</strong>: 使用 CAS (Compare-And-Swap) 原子操作来保证入队和出队的线程安全，避免了使用传统锁（自旋锁的底层也是 CAS）。更极致的实现可以参考 LMAX Disruptor 中的环形缓冲区（Ring Buffer）。</li></ul></li> <li><p><strong>分发器 (Dispatcher / Producer Logic)</strong></p> <ul><li>它接收所有外部传入的消息。</li> <li>对于每条消息，它执行以下操作：
<ol><li>提取消息的路由键（Routing Key）。</li> <li>计算该键的哈希值。</li> <li>通过哈希环查找此哈希值应由哪个 Worker Thread 处理。</li> <li>将消息放入该 Worker Thread 专属的无锁队列中。</li></ol></li></ul></li></ol> <h3 id="三、-工作流程详解"><a href="#三、-工作流程详解" class="header-anchor">#</a> 三、 工作流程详解</h3> <ol><li><p><strong>系统初始化</strong>:</p> <ul><li>创建 N 个 Worker Thread。</li> <li>为每个 Worker Thread 创建一个专属的 MPSC 无锁队列。</li> <li>构建哈希环，并将这 N 个 Worker Thread 注册到环上。</li> <li>启动所有 Worker Thread。每个线程都进入一个循环，不断尝试从自己的队列中获取并处理消息。</li></ul></li> <li><p><strong>消息处理流程</strong>:</p> <ul><li><strong>消息到达</strong>: 外部生产者将一条消息（例如，一个包含 <code>userId</code> 的订单请求）发送给分发器。</li> <li><strong>路由</strong>: 分发器提取 <code>userId</code>，计算其哈希值。</li> <li><strong>定位</strong>: 分发器在哈希环上定位到该哈希值对应的 Worker Thread（例如，Thread-3）。</li> <li><strong>入队</strong>: 分发器调用 Thread-3 专属队列的 <code>offer()</code> 方法，将消息放入队列。这是一个无锁的 CAS 操作。</li> <li><strong>处理</strong>: Thread-3 在其处理循环中，从自己的队列中 <code>poll()</code> 出这条消息，并执行业务逻辑。由于只有 Thread-3 自己会从这个队列读数据，所以 <code>poll()</code> 操作也无需与其他消费者线程竞争。</li></ul></li></ol> <h3 id="四、-如何实现-无锁-与-并发安全"><a href="#四、-如何实现-无锁-与-并发安全" class="header-anchor">#</a> 四、 如何实现“无锁”与“并发安全”</h3> <ul><li><strong>消费端完全无锁</strong>: 因为每个 Worker Thread 只操作自己的队列，线程之间不存在任何共享数据，因此在消费端是 100% 无锁的，并行度极高。</li> <li><strong>生产端（分发器）是“轻量锁”或“无锁”</strong>: 多个生产者或分发器线程可能会同时往<strong>同一个</strong>专属队列中写入消息。通过底层的 CAS 原子操作来处理这种并发写入，避免了操作系统级别的重量级锁，性能远高于锁。</li> <li><strong>内存可见性保证</strong>: 无锁队列的实现会利用内存屏障（Memory Barriers）来确保一个线程写入的数据对另一个线程是可见的，从而保证了线程安全。</li> <li><strong>天然的顺序保证</strong>: 这是此架构的另一个巨大优势。由于所有具有相同 <code>userId</code> 的消息总是被哈希到环上的同一点，因此它们总是会被同一个 Worker Thread 按顺序放入其队列中，并按顺序处理。这就在无需任何额外锁的情况下，保证了<strong>单个业务键（如用户）操作的严格顺序性</strong>。</li></ul> <h3 id="五、-实践挑战与考量"><a href="#五、-实践挑战与考量" class="header-anchor">#</a> 五、 实践挑战与考量</h3> <ol><li><p><strong>处理“热点 Key”问题</strong>: 如果某个 <code>userId</code> 的消息量远超其他用户，会导致映射到该用户的那个 Worker Thread 负载过高，而其他线程可能很空闲。</p> <ul><li><strong>解决方案</strong>: 可以设计更复杂的哈希策略，或者在分发器层面识别热点 Key，并将其消息分散到一组线程中处理（但这会牺牲顺序性）。
或者，创建多个虚拟节点，让这几个虚拟节点均匀分布在哈希环中，增加虚拟节点到真实节点的映射，然后发送给虚拟节点的消息传给真实工作节点即可</li></ul></li> <li><p><strong>动态扩缩容 Worker Threads</strong>: 当需要增加或减少 Worker Thread 时，需要更新哈希环。</p> <ul><li><strong>优势</strong>: 哈希环（一致性哈希）的优点在于，增加或删除一个节点（线程），只会影响环上相邻的一小部分 Key 的映射关系，而不会导致所有 Key 的重新洗牌，这使得扩缩容的成本相对较低。</li> <li><strong>操作</strong>: 需要平滑地迁移数据，即在更新哈希环后，旧线程需要处理完队列中剩余的消息，同时新消息已经开始路由到新的线程。</li></ul></li> <li><p><strong>队列积压与反压 (Back-Pressure)</strong>: 如果使用无界队列，如果分发器速度远快于 Worker Thread 的处理速度，会导致内存溢出。</p> <ul><li><strong>解决方案</strong>: 需要监控每个专属队列的长度。当队列长度超过阈值时，分发器可以暂时阻塞、丢弃消息或通知生产者降速，这就是反压机制。或者可以使用有界的无锁队列。</li></ul></li></ol> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p><strong>与传统模型的对比：</strong></p> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;">传统模型 (共享队列 + 锁)</th> <th style="text-align:left;">无锁模型 (哈希环 + 专用队列)</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>核心思想</strong></td> <td style="text-align:left;">线程争夺任务</td> <td style="text-align:left;">系统分配任务</td></tr> <tr><td style="text-align:left;"><strong>并发控制</strong></td> <td style="text-align:left;">重量级锁 (synchronized, Lock)</td> <td style="text-align:left;">CAS 原子操作 (Lock-Free)</td></tr> <tr><td style="text-align:left;"><strong>性能瓶颈</strong></td> <td style="text-align:left;">锁竞争、上下文切换</td> <td style="text-align:left;">CPU Cache Miss、内存带宽</td></tr> <tr><td style="text-align:left;"><strong>顺序保证</strong></td> <td style="text-align:left;">难以保证，需要额外复杂逻辑</td> <td style="text-align:left;">按 Key 天然保证</td></tr> <tr><td style="text-align:left;"><strong>缓存亲和性</strong></td> <td style="text-align:left;">差，任务可能在不同 CPU 核心切换</td> <td style="text-align:left;">好，同一 Key 的数据总由同一线程处理</td></tr> <tr><td style="text-align:left;"><strong>复杂度</strong></td> <td style="text-align:left;">实现相对简单</td> <td style="text-align:left;">实现复杂，对数据结构要求高</td></tr></tbody></table> <h2 id="还能不能继续优化-协程-有的兄弟-有的"><a href="#还能不能继续优化-协程-有的兄弟-有的" class="header-anchor">#</a> 还能不能继续优化？协程：有的兄弟，有的</h2> <p>在上面使用多线程的版本中，每个工作线程如果遇到长耗时操作会导致其他消息的处理被阻塞，可能有短时操作可以先进行呢？（这就扯到调度了）
它在上一版“多线程+哈希环”的基础上，引入了协程（Coroutines/Green Threads/Fibers）作为第二层并发，专门用于解决 I/O 密集型任务的效率问题。</p> <p><strong>核心思想：</strong></p> <ol><li><strong>线程负责计算（CPU-Bound）和调度</strong>：使用固定的、数量与 CPU 核心数相关的线程池。每个线程绑定到一个 CPU 核心上，避免线程切换带来的上下文开销。这称为<strong>线程亲和性（Thread Affinity）</strong>。</li> <li><strong>协程负责并发（I/O-Bound）和业务逻辑</strong>：在每一个固定的线程内部，可以运行成千上万个协程。当一个协程遇到 I/O 操作（如数据库查询、API 调用）时，它会 <strong>挂起（Suspend）</strong> 自身，而不是阻塞整个线程。该线程会立刻转去执行其他就绪的协程。</li></ol> <p>这种模型也被称为 <strong>M:N 调度模型</strong>，即 M 个协程运行在 N 个操作系统线程上。</p> <h3 id="一、-架构组件"><a href="#一、-架构组件" class="header-anchor">#</a> 一、 架构组件</h3> <p>这个系统的组件比之前更加精细化：</p> <ol><li><p><strong>前端分发器 (Frontend Dispatcher) + 哈希环 (Hash Ring)</strong></p> <ul><li><strong>职责</strong>：与之前一样，它的唯一职责是<strong>路由</strong>。它接收所有外部消息，通过哈希环计算出消息应该由哪个**工作线程（Worker Thread）**处理，然后将消息放入该线程的专属队列中。</li></ul></li> <li><p><strong>工作线程 (Worker Threads) - 现在是协程调度器</strong></p> <ul><li><strong>角色转变</strong>：这里的 Worker Thread 不再是直接执行业务逻辑的单元。它的核心角色变成了一个<strong>事件循环（Event Loop）<strong>或</strong>协程调度器（Coroutine Scheduler）</strong>。</li> <li><strong>数量</strong>：通常设置为与 CPU 核心数相等或略多。</li> <li><strong>职责</strong>：
<ul><li>从自己的专属消息队列中取出消息。</li> <li>为每一条消息<strong>启动一个新的协程</strong>来处理。</li> <li>管理其上运行的所有协程的生命周期（创建、挂起、恢复、销毁）。</li> <li>持续循环，执行就绪的协程。</li></ul></li></ul></li> <li><p><strong>MPSC 无锁队列 (MPSC Lock-Free Queue)</strong></p> <ul><li><strong>职责</strong>：依然是连接分发器和工作线程的桥梁。它允许多个分发器线程（Producers）安全地向队列中写入消息，但只允许唯一一个工作线程（Consumer）从中读取。这是保证线程间无锁通信的关键。</li></ul></li> <li><p><strong>协程 (Coroutines) - 真正的业务执行者</strong></p> <ul><li><strong>职责</strong>：执行单个消息的完整业务逻辑。</li> <li><strong>核心特性</strong>：当协程需要进行网络请求、数据库访问等耗时 I/O 操作时，它会调用一个<strong>非阻塞 I/O 库</strong>，并<strong>挂起</strong>自己。控制权会立刻交还给它所在的 Worker Thread 的调度器。</li> <li><strong>生命周期</strong>：一个协程的生命周期通常与一条消息的处理周期相对应。处理完毕后，协程销毁，资源被回收。</li></ul></li></ol> <h3 id="二、-详细工作流程"><a href="#二、-详细工作流程" class="header-anchor">#</a> 二、 详细工作流程</h3> <ol><li><p><strong>初始化</strong>:</p> <ul><li>系统启动时，创建 N 个 Worker Thread，并将每个线程绑定到一个 CPU 核心上（如果操作系统支持）。</li> <li>为每个 Worker Thread 创建一个 MPSC 无锁队列。</li> <li>为每个 Worker Thread 启动一个协程调度器/事件循环。</li> <li>构建哈希环，将 N 个 Worker Thread 的队列注册到环上。</li></ul></li> <li><p><strong>消息处理的旅程</strong>:</p> <ul><li><strong>(1) 路由 (Dispatcher)</strong>：一条包含 <code>orderId</code> 的消息到达分发器。分发器计算 <code>orderId</code> 的哈希，通过哈希环定位到 <strong>Worker Thread 2</strong>。</li> <li><strong>(2) 入队 (Queue)</strong>：分发器将消息原子性地（通过 CAS 操作）放入 Worker Thread 2 的专属无锁队列 <code>Queue-2</code> 中。</li> <li><strong>(3) 调度 (Worker Thread)</strong>：Worker Thread 2 的事件循环一直在轮询 <code>Queue-2</code>。它发现了新消息。</li> <li><strong>(4) 启动协程 (Coroutine)</strong>：Worker Thread 2 的调度器立即为这条消息<strong>创建一个新的协程（Coroutine A）</strong>，并开始执行其代码。</li> <li><strong>(5) 业务处理与 I/O 挂起)</strong>：
<ul><li>Coroutine A 开始执行业务逻辑，比如需要查询数据库获取商品信息。</li> <li>它调用一个异步数据库驱动的 <code>query()</code> 方法。这个调用<strong>不会阻塞 Worker Thread 2</strong>。</li> <li>Coroutine A 的状态变为“挂起”，并注册一个回调（当数据库返回结果时唤醒我）。</li> <li><strong>Worker Thread 2 的控制权被立即释放！</strong></li></ul></li> <li><strong>(6) 并发执行 (Worker Thread)</strong>：Worker Thread 2 没有被阻塞，它的事件循环继续：
<ul><li>它可能去 <code>Queue-2</code> 检查是否有新消息，并为新消息创建 <strong>Coroutine B</strong>。</li> <li>它可能发现之前某个被挂起的 <strong>Coroutine C</strong>（比如一个 API 调用）现在 I/O 操作完成了，于是<strong>恢复（Resume）</strong> Coroutine C 的执行。</li></ul></li> <li><strong>(7) I/O 完成与恢复 (Callback &amp; Resume)</strong>：
<ul><li>数据库操作完成，通过网络回调通知系统。</li> <li>Worker Thread 2 的调度器收到通知，将 Coroutine A 的状态从“挂起”变为“就绪”。</li> <li>在下一次调度机会时，Worker Thread 2 会从上次挂起的地方继续执行 Coroutine A 的代码，此时它已经拿到了数据库查询结果。</li></ul></li> <li><strong>(8) 完成</strong>: Coroutine A 执行完所有逻辑，生命周期结束。</li></ul></li></ol> <h3 id="三、-如何实现-语言-框架映射"><a href="#三、-如何实现-语言-框架映射" class="header-anchor">#</a> 三、 如何实现？（语言/框架映射）</h3> <p>现代有一些语言就已经支持了这种高性能框架，比如 Go，Rust
其中 Go 是更倾向于云原生的，因此也就更好实现
Rust 可以使用像 tokio 这样的异步运行时，但它不像 Go 那样，对于协程有一个专门的实体并对此进行调度，而是抽象成任务，在已有的工作线程上一任务为单位进行调度，具体可见 <a href="https://sparkzky.github.io/posts/6.html" target="_blank" rel="noopener noreferrer">tokio<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li><p><strong>Go 语言</strong>: 这是 Go 语言的<strong>原生并发模型</strong>。</p> <ul><li><strong>协程</strong>: <code>goroutine</code></li> <li><strong>工作线程</strong>: Go 运行时的 <code>P</code> (Processor)，数量默认等于 <code>GOMAXPROCS</code>。</li> <li><strong>MPSC 队列</strong>: <code>channel</code></li> <li><strong>调度器</strong>: Go runtime scheduler 会自动处理 <code>goroutine</code> 在线程上的调度（G-M-P 模型）。只需要用哈希来决定将消息发送到哪个 <code>channel</code> 即可。</li></ul></li> <li><p><strong>Rust</strong>: 使用 <code>tokio</code> 或 <code>async-std</code> 运行时。</p> <ul><li><strong>工作线程/调度器</strong>: <code>tokio</code> 运行时默认会创建一个多线程的调度器。你可以配置工作线程数。</li> <li><strong>MPSC 队列</strong>: <code>tokio::sync::mpsc::channel</code>。</li> <li><strong>协程</strong>: <code>async</code> 块和 <code>Future</code> Trait，通过 <code>tokio::spawn</code> 运行。</li> <li>同样，需要自己实现哈希环逻辑，将任务发送到正确的 MPSC channel。</li></ul></li></ul> <h2 id="虚拟节点的引入会导致顺序性失效吗"><a href="#虚拟节点的引入会导致顺序性失效吗" class="header-anchor">#</a> 虚拟节点的引入会导致顺序性失效吗</h2> <p>将虚拟节点均匀分布，然后多对一映射到真实节点正是<strong>标准且正确</strong>的解决方案。但“顺序性失效”问题，其根源不在于虚拟节点这个技术本身，而在于<strong>如何定义和使用哈希的“键”（Key）</strong>。</p> <h3 id="一、-问题根源-哈希的是什么"><a href="#一、-问题根源-哈希的是什么" class="header-anchor">#</a> 一、 问题根源：哈希的是什么？</h3> <p>顺序性保证的<strong>唯一</strong>前提是：<strong>对于同一个业务实体（如同一个用户），其产生的所有消息，经过哈希计算后，必须总是定位到环上的同一点。</strong></p> <p><strong>错误的实现方式：</strong>
哈希的是<strong>整条消息</strong>或者<strong>消息的某个易变部分</strong>。</p> <ul><li><p><strong>例子</strong>：</p> <ol><li><code>Message1 = { &quot;userId&quot;: 123, &quot;action&quot;: &quot;login&quot;, &quot;timestamp&quot;: 1668888888 }</code></li> <li><code>Message2 = { &quot;userId&quot;: 123, &quot;action&quot;: &quot;purchase&quot;, &quot;timestamp&quot;: 1669999999 }</code></li></ol> <p>如果计算 <code>hash(Message1)</code> 和 <code>hash(Message2)</code>，由于 <code>action</code> 和 <code>timestamp</code> 不同，你会得到两个<strong>完全不同</strong>的哈希值。这两个哈希值会落在环上的不同位置，从而可能被路由到不同的虚拟节点，进而被路由到不同的真实工作节点。</p> <p><strong>这样，<code>userId=123</code> 的两条消息就被两个不同的节点处理了，顺序性被彻底破坏。</strong></p></li></ul> <h3 id="二、-正确的解决方案-稳定路由键-虚拟节点"><a href="#二、-正确的解决方案-稳定路由键-虚拟节点" class="header-anchor">#</a> 二、 正确的解决方案：稳定路由键 + 虚拟节点</h3> <p>要同时实现负载均衡和顺序性，必须结合以下两个关键点：</p> <h4 id="_1-核心原则-使用稳定的-路由键-routing-key"><a href="#_1-核心原则-使用稳定的-路由键-routing-key" class="header-anchor">#</a> <strong>1. 核心原则：使用稳定的“路由键” (Routing Key)</strong></h4> <ul><li><strong>定义</strong>：路由键是消息中能够唯一标识“需要保证顺序性的业务实体”的字段。在上面的例子中，这个字段就是 <code>userId</code>。</li> <li><strong>规则</strong>：哈希函数<strong>必须且只能</strong>作用于这个路由键上，而不是整条消息。</li></ul> <p>因为输入是相同的（都是字符串 &quot;123&quot;），所以哈希函数的输出永远是相同的。这意味着，<code>userId=123</code> 的所有消息，无论内容是什么，都会被初始定位到哈希环上的<strong>同一个点</strong>。</p> <h4 id="_2-虚拟节点的正确用法"><a href="#_2-虚拟节点的正确用法" class="header-anchor">#</a> <strong>2. 虚拟节点的正确用法</strong></h4> <ol><li><p><strong>建立映射</strong>:</p> <ul><li>为每个真实工作节点（如 <code>Worker-A</code>, <code>Worker-B</code>）创建多个虚拟节点。关键在于，虚拟节点的名字要能反向映射回真实节点。</li> <li>例如：<code>Worker-A</code> -&gt; <code>[&quot;Worker-A-v1&quot;, &quot;Worker-A-v2&quot;, &quot;Worker-A-v3&quot;]</code></li> <li><code>Worker-B</code> -&gt; <code>[&quot;Worker-B-v1&quot;, &quot;Worker-B-v2&quot;, &quot;Worker-B-v3&quot;]</code></li> <li>将这 6 个虚拟节点的名字进行哈希，把它们分布在环上。</li></ul></li> <li><p><strong>路由流程</strong>:</p> <ul><li>来了一条消息，<code>{ &quot;userId&quot;: 123, ... }</code>。</li> <li>提取路由键 <code>userId</code>，值为 <code>123</code>。</li> <li>计算 <code>h = hash(&quot;123&quot;)</code>。</li> <li>在环上从 <code>h</code> 点顺时针查找，找到的第一个虚拟节点是 <code>Worker-B-v2</code>。</li> <li>根据虚拟节点的名字，我们知道它属于 <code>Worker-B</code>。</li> <li>将这条消息发送给真实的工作节点 <code>Worker-B</code>。</li></ul></li></ol> <p><strong>为什么这样就保证了顺序性？</strong></p> <p>因为对于所有 <code>userId=123</code> 的消息，<code>hash(&quot;123&quot;)</code> 的结果是固定的。只要哈希环的节点（虚拟节点）不发生增删，这个哈希值顺时针找到的第一个虚拟节点<strong>永远是同一个</strong>（比如永远是 <code>Worker-B-v2</code>），因此这些消息<strong>永远会被路由到同一个真实节点</strong>（<code>Worker-B</code>）。</p> <p>虚拟节点在这里的作用，仅仅是让真实节点在环上的“存在感”更分散、更均匀，从而使得整体的数据分布更均衡。它并没有改变“一个路由键固定映射到一个处理单元”这个核心逻辑。</p> <h3 id="三、-动态伸缩时的顺序性问题-这才是真正的挑战"><a href="#三、-动态伸缩时的顺序性问题-这才是真正的挑战" class="header-anchor">#</a> 三、 动态伸缩时的顺序性问题（这才是真正的挑战）</h3> <p>真正可能<strong>暂时</strong>破坏顺序性的是<strong>动态伸缩</strong>，即在运行时增加或删除真实工作节点。</p> <ul><li><strong>场景</strong>：假设我们增加了一个 <code>Worker-C</code>，并将其虚拟节点 <code>Worker-C-v1</code>, <code>Worker-C-v2</code>, ... 加入到环中。</li> <li><strong>影响</strong>：
<ul><li>现在，原来 <code>hash(&quot;123&quot;)</code> 顺时针找到的 <code>Worker-B-v2</code>，中间可能插入了一个 <code>Worker-C-v1</code>。</li> <li>于是，从这一刻起，所有 <code>userId=123</code> 的新消息都会开始被路由到 <code>Worker-C</code>。</li> <li><strong>问题来了</strong>：此时，<code>Worker-B</code> 的队列里可能还有一些未处理完的、属于 <code>userId=123</code> 的旧消息。如果不做任何处理，就会出现新消息在 <code>Worker-C</code> 被处理，而旧消息稍后才在 <code>Worker-B</code> 被处理的<strong>乱序</strong>情况。</li></ul></li></ul> <h4 id="解决动态伸缩时的乱序问题"><a href="#解决动态伸缩时的乱序问题" class="header-anchor">#</a> <strong>解决动态伸缩时的乱序问题</strong></h4> <p>这是一个有状态系统伸缩时必须面对的“状态迁移”问题，有几种成熟的策略：</p> <ol><li><p><strong>优雅切换 (Graceful Handoff)</strong>：</p> <ul><li>当确定 <code>userId=123</code> 的归属要从 <code>Worker-B</code> 迁移到 <code>Worker-C</code> 时：</li> <li><code>Worker-B</code> 停止接收该 <code>userId</code> 的新消息。</li> <li><code>Worker-B</code> 将其内存中关于 <code>userId=123</code> 的所有状态数据（上下文）打包，并通过一个协调服务（如 ZooKeeper）或直接点对点发送给 <code>Worker-C</code>。</li> <li>同时，<code>Worker-B</code> 要处理完其内部队列中所有 <code>userId=123</code> 的存量消息。</li> <li><code>Worker-C</code> 收到状态数据后加载到内存，然后才开始处理该 <code>userId</code> 的新消息。</li> <li>这个过程比较复杂，但能保证严格的顺序性。</li></ul></li> <li><p><strong>“粘滞会话” + 延迟迁移 (Sticky Sessions + Delayed Migration)</strong>:</p> <ul><li>当节点变化后，系统可以记录下哪些 Key 需要迁移。</li> <li>但对于正在处理的会话（比如一个活跃用户的操作序列），可以暂时让它“粘滞”在旧节点 <code>Worker-B</code> 上，直到这个会话结束（例如用户登出或一段时间不活跃）。</li> <li>新的会话则直接在新节点 <code>Worker-C</code> 上开始。</li></ul></li></ol> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <table><thead><tr><th style="text-align:left;">做法</th> <th style="text-align:left;">目的</th> <th style="text-align:left;">是否破坏顺序性？</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>使用虚拟节点</strong></td> <td style="text-align:left;"><strong>负载均衡</strong></td> <td style="text-align:left;"><strong>否</strong>。只要你哈希的是稳定的路由键，顺序性 100% 保证。</td></tr> <tr><td style="text-align:left;"><strong>哈希整条消息</strong></td> <td style="text-align:left;">(错误的做法)</td> <td style="text-align:left;"><strong>是</strong>。这会彻底破坏顺序性。</td></tr> <tr><td style="text-align:left;"><strong>动态增删节点</strong></td> <td style="text-align:left;"><strong>系统伸缩</strong></td> <td style="text-align:left;"><strong>是，在伸缩的瞬间会暂时破坏</strong>。必须通过状态迁移等复杂策略来解决。</td></tr></tbody></table></div></div> <!----></div> <div class="footer" data-v-3ef679b5><div class="footer-content page" data-v-3ef679b5><div class="left" data-v-3ef679b5><div class="footer-title" data-v-3ef679b5>FRIEND LINKS</div> <div class="links footer-text" data-v-3ef679b5></div> <div class="footer-text" data-v-3ef679b5><span id="busuanzi_container_site_pv" class="footer-count" data-v-3ef679b5><span id="busuanzi_value_site_pv" data-v-3ef679b5></span> <span id="busuanzi_value_site_uv" data-v-3ef679b5></span></span> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>PAGE VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>USER VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div></div> </div> <div class="right" data-v-3ef679b5><div class="footer-title power" data-v-3ef679b5>POWERED BY</div> <a href="https://github.com/Yidadaa/Issue-Blog-With-Github-Action" class="logo" data-v-3ef679b5>ISSUE BLOG</a></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.392e1bce.js" defer></script><script src="/assets/js/11.a00298db.js" defer></script><script src="/assets/js/4.6f43f24c.js" defer></script><script src="/assets/js/8.ddba2f81.js" defer></script><script src="/assets/js/23.c2601bd2.js" defer></script><script src="/assets/js/3.91df9f30.js" defer></script>
  </body>
</html>
