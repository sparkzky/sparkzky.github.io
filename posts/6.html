<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>异步运行时 | Sparkzky&#39;s Blog</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="stylesheet" href="https://cdn.bootcss.com/prism/9000.0.1/themes/prism.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/KaTeX/0.5.1/katex.min.css">
    <script charset="utf-8" src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async="true"></script>
    <link rel="icon" type="image/png" href="https://avatars.githubusercontent.com/u/146502758?s=400&amp;u=b8a39089c210f747787383af20846de9556386c8&amp;v=4">
    <meta name="description" content="Nothing to be found">
    
    <link rel="preload" href="/assets/css/0.styles.219b403a.css" as="style"><link rel="preload" href="/assets/js/app.a90fafec.js" as="script"><link rel="preload" href="/assets/js/11.a00298db.js" as="script"><link rel="preload" href="/assets/js/4.6f43f24c.js" as="script"><link rel="preload" href="/assets/js/8.ddba2f81.js" as="script"><link rel="preload" href="/assets/js/22.bfacb966.js" as="script"><link rel="preload" href="/assets/js/3.91df9f30.js" as="script"><link rel="prefetch" href="/assets/js/10.5dbe98a1.js"><link rel="prefetch" href="/assets/js/12.516ada50.js"><link rel="prefetch" href="/assets/js/13.ed14be29.js"><link rel="prefetch" href="/assets/js/14.fe23fc6f.js"><link rel="prefetch" href="/assets/js/15.802e7bec.js"><link rel="prefetch" href="/assets/js/16.b507aa79.js"><link rel="prefetch" href="/assets/js/17.87d50f46.js"><link rel="prefetch" href="/assets/js/18.584f55d9.js"><link rel="prefetch" href="/assets/js/19.56b8692f.js"><link rel="prefetch" href="/assets/js/2.cf254b8a.js"><link rel="prefetch" href="/assets/js/20.a0437c1b.js"><link rel="prefetch" href="/assets/js/21.0099b358.js"><link rel="prefetch" href="/assets/js/23.c2601bd2.js"><link rel="prefetch" href="/assets/js/5.7ca9e7a7.js"><link rel="prefetch" href="/assets/js/6.8c5f5d5e.js"><link rel="prefetch" href="/assets/js/7.7f0a3a0f.js"><link rel="prefetch" href="/assets/js/9.83a765f6.js">
    <link rel="stylesheet" href="/assets/css/0.styles.219b403a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div><div class="header-wrap" data-v-33920667><div class="header page" data-v-33920667><div class="left" data-v-33920667><div class="motto" data-v-33920667></div> <div class="nav" data-v-33920667></div></div> <div class="right" data-v-33920667><div class="search-box" data-v-33920667><input aria-label="Search" placeholder="" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></div> <div class="page post-page"><div class="title"><div class="post-title">异步运行时</div></div> <div class="info"><div class="author">sparkzky</div> <div class="date">2025/09/24</div> <div class="count"><span id="busuanzi_value_page_pv"></span> <span>views</span></div></div> <div class="post-content"><div class="content__default"><h1 id="异步运行时"><a href="#异步运行时" class="header-anchor">#</a> 异步运行时</h1> <h2 id="异步运行时-2"><a href="#异步运行时-2" class="header-anchor">#</a> 异步运行时</h2> <p>一个异步运行时主要做以下几件事：</p> <ul><li><p>管理和调度异步任务 (Futures/Tasks)：</p> <p>当使用 tokio::spawn 启动一个新的 Future 时，运行时会把它包装成一个 Task，并放入自己的任务队列中等待执行。它会不断地检查哪些任务可以继续执行（即 &quot;ready&quot;），然后调用它们的 poll 方法来推进它们。</p></li> <li><p>处理非阻塞 I/O (Non-Blocking I/O)：</p> <p>运行时通过底层操作系统提供的机制（如 Linux 的 epoll, macOS 的 kqueue, Windows 的 IOCP）将这些 I/O 操作注册为“感兴趣的事件”。
当一个 I/O 操作（比如网络数据包到达）准备好时，操作系统会通知运行时，然后运行时就知道哪个等待这个事件的任务可以被唤醒并继续执行了。</p></li> <li><p>管理计时器 (Timers)：</p> <p>运行时内部会维护一个有序的计时器队列。当一个 sleep 任务被安排时，运行时会记录下它需要唤醒的时间。当时间到达时，运行时会唤醒相应的任务。</p></li> <li><p>提供线程池 (Thread Pool)：</p> <p>虽然异步代码的目的是避免阻塞，但有时仍然需要执行一些 CPU 密集型任务或必须使用阻塞式 API 的操作（例如，进行复杂的加密计算，或者调用一些老旧的同步 C 库）。
Tokio 提供 tokio::task::spawn_blocking 这样的机制，可以将这些阻塞性任务提交到一个单独的线程池中执行，而不会阻塞主异步运行时所在的线程。</p></li> <li><p>资源管理与错误处理：</p> <p>协助管理异步任务的生命周期，例如当一个任务被取消时，清理相关资源。提供结构化的错误处理机制，例如通过 Result 类型传播异步操作的错误。</p></li></ul> <h2 id="异步运行时底层支持-future-waker-eventloop-i-o-multiplexing"><a href="#异步运行时底层支持-future-waker-eventloop-i-o-multiplexing" class="header-anchor">#</a> 异步运行时底层支持（Future，Waker，EventLoop，I/O Multiplexing）</h2> <h3 id="future"><a href="#future" class="header-anchor">#</a> Future</h3> <p>这是 Rust 异步编程的基本构建块。一个 async fn 编译后会生成一个实现了 Future trait 的状态机。</p> <p>Future trait 定义了一个核心方法：poll。</p> <p>Rust 中的 poll 方法的签名是
<code>fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;</code></p> <p>Poll::Ready(value)： 表示 Future 已经完成，并返回了结果 value。</p> <p>Poll::Pending： 表示 Future 尚未完成，需要等待某个条件（例如 I/O 完成或计时器到期）才能继续。当返回 Pending 时，Future 必须确保在条件满足时，通过 Waker 机制通知运行时来再次 poll 自己。</p> <h3 id="waker"><a href="#waker" class="header-anchor">#</a> Waker</h3> <p>这是异步运行时能够“唤醒”一个 Pending 的 Future 的关键机制。</p> <p>当一个 Future 在 poll 方法中返回 Pending 时，它会通过 Context 获取到一个 Waker 的副本（以及注册感兴趣的事件）。这个 Waker 可以被存储起来（例如，存储在一个 I/O 事件的注册表中）。</p> <p>当外部事件（如操作系统通知网络数据已到达，或者计时器到期）发生时，对应的 Waker 会被调用其 wake() 方法。wake() 方法会通知运行时：那个关联的 Future 现在可能已经准备好再次被 poll 了，把它放回任务队列中。</p> <h3 id="context"><a href="#context" class="header-anchor">#</a> Context</h3> <p>Context 对象在 poll 方法中传递，它包含了当前 Future 的 Waker。它允许 Future 在返回 Pending 之前，将自己的 Waker 注册到某个地方，以便在条件满足时被唤醒。</p> <h3 id="底层运行机制-以-tokio-为例"><a href="#底层运行机制-以-tokio-为例" class="header-anchor">#</a> 底层运行机制（以 Tokio 为例）：</h3> <h4 id="任务封装-task"><a href="#任务封装-task" class="header-anchor">#</a> 任务封装 (Task)：</h4> <p>当调用 tokio::spawn(my_async_op()) 时，my_async_op() 返回的 Future 会被 Tokio 运行时包装成一个内部的 Task 结构。这个 Task 包含 Future 本身以及一个唯一的 ID 或指针。</p> <p>这个 Task 被放入一个就绪队列 (Ready Queue)。</p> <h4 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环 (Event Loop)：</h4> <p>Tokio 运行时的一个或多个工作线程 (worker threads) 会运行一个无限循环，这就是事件循环。
在每个循环迭代中，它会做几件事：</p> <ol><li><p>从就绪队列中取出任务： 运行时会从就绪队列中弹出一个 Task。</p></li> <li><p>驱动任务： 运行时会调用这个 Task 内部 Future 的 poll 方法。</p> <p>如果 poll 返回 Poll::Ready(value)，任务完成，其结果被处理，Task 资源被清理。
如果 poll 返回 Poll::Pending，说明任务暂时无法继续。此时，Future 内部已经将自身的 Waker 注册到了它所等待的资源（如网络套接字、计时器）上。该任务会被暂时移除出就绪队列。</p></li> <li><p>等待事件：
如果就绪队列为空，或者所有当前的 Future 都返回了 Pending，运行时会进入一个阻塞状态，等待操作系统通知有新的 I/O 事件发生，或者等待下一个计时器事件到期。这是通过 I/O 多路复用 机制实现的（如 epoll_wait, kqueue, GetQueuedCompletionStatus）。</p></li> <li><p>处理事件并唤醒任务：
当操作系统通知有 I/O 事件发生时，运行时会通过事先存储的 Waker 找到对应的 Task，调用其 wake() 方法。这个 wake() 调用会把 Task 重新放回就绪队列中，等待在下一个循环迭代中被 poll。</p></li></ol> <h4 id="i-o-多路复用-i-o-multiplexing"><a href="#i-o-多路复用-i-o-multiplexing" class="header-anchor">#</a> I/O 多路复用 (I/O Multiplexing)：</h4> <p>这是高效处理大量并发 I/O 的关键。运行时不是为每个连接或文件打开一个线程，而是使用一个单独的机制（如 epoll）来同时监控成千上万个 I/O 句柄。</p> <p>例如，当一个 TCP socket 上有数据可读时，epoll 会通知运行时，然后运行时就知道哪个 Future 正在等待这个 socket 的数据，并唤醒它。</p> <h4 id="计时器驱动-timer-driver"><a href="#计时器驱动-timer-driver" class="header-anchor">#</a> 计时器驱动 (Timer Driver)：</h4> <p>Tokio 内部有一个高效的计时器轮 (timer wheel) 或类似的结构来管理大量的 tokio::time::sleep() 调用。</p> <p>当 sleep 到期时，计时器驱动会唤醒相应的 Task。</p> <h4 id="工作线程池-worker-thread-pool"><a href="#工作线程池-worker-thread-pool" class="header-anchor">#</a> 工作线程池 (Worker Thread Pool)：</h4> <p>Tokio 默认会启动一个由多个操作系统线程组成的工作线程池。每个线程都运行自己的事件循环。</p> <p>这使得 Tokio 可以在多核 CPU 上实现真正的并行度。任务可以被调度到任何一个空闲的工作线程上执行。</p> <p>tokio::task::spawn_blocking 则是将阻塞任务提交到一个单独的阻塞线程池中，确保这些阻塞操作不会影响主事件循环的响应性。</p> <h2 id="对-tokio-的大概理解"><a href="#对-tokio-的大概理解" class="header-anchor">#</a> 对 Tokio 的大概理解</h2> <p>简单看来，tokio 就像是使用了 rust 的语言特性，包装了系统底层的 io 多路复用机制，然后向上层提供异步服务而已？</p> <p>这个理解从一定程度上来说是正确的，但 tokio 不只是一个简单的“包装”，而是一个提供了许多关键组件来实现上述功能的完整、强大且易于使用的异步运行时</p> <p><strong>顶层：用户友好的异步 API (User-Friendly Async APIs)</strong></p> <p>这是直接使用的部分，例如 <code>tokio::spawn</code>, <code>tokio::net::TcpStream</code>, <code>tokio::sync::Mutex</code> 等。它们遵循 Rust 的 <code>async/await</code> 语法，能够编写看似同步的异步代码。</p> <p><strong>中层：Tokio 运行时 (The Tokio Runtime)</strong></p> <ul><li><p>调度器 (Scheduler): 这是 Tokio 最复杂的部分之一。它负责管理成千上万的异步任务（Task），决定下一个应该执行哪个任务。它还实现了工作窃取 (work-stealing) 算法，使得在多线程模式下，空闲的工作线程可以从繁忙的线程那里“窃取”任务来执行，从而最大化 CPU 利用率。</p></li> <li><p>计时器系统 (Timer System): 提供 tokio::time::sleep 等功能，下面会详细讲。</p></li> <li><p>异步原语 (Async Primitives): 提供了专门为异步环境设计的同步工具，如 Mutex, Semaphore, Channels (mpsc, oneshot 等)。</p></li> <li><p>阻塞任务处理器 (Blocking Task Handler): 通过 spawn_blocking 将会阻塞线程的代码移到专用的线程池，防止其“毒害”主事件循环。</p></li></ul> <p><strong>底层：对操作系统 API 的抽象 (OS API Abstraction)</strong></p> <p>Tokio 封装了不同操作系统提供的 I/O 多路复用机制：</p> <div class="language- extra-class"><pre><code>Linux: epoll
macOS / BSD: kqueue
Windows: IOCP (I/O Completion Ports)
</code></pre></div><p>mio 提供了一个统一的、跨平台的、底层的 API。Tokio 在此基础上构建其 I/O 驱动，当 mio 报告某个 I/O 句柄（如一个网络套接字）准备好读或写时，Tokio 就会唤醒等待这个事件的那个异步任务。</p> <h2 id="一些细节"><a href="#一些细节" class="header-anchor">#</a> 一些细节</h2> <h3 id="一些在标准库的实现-在-tokio-中有另一个版本-为什么-比如-std-mutex-和-tokio-mutex"><a href="#一些在标准库的实现-在-tokio-中有另一个版本-为什么-比如-std-mutex-和-tokio-mutex" class="header-anchor">#</a> 一些在标准库的实现，在 tokio 中有另一个版本，为什么？(比如 std::mutex 和 tokio::mutex)</h3> <p><strong>最大的区别在于当锁已经被持有时，另一个任务尝试获取锁的行为。</strong></p> <ul><li><strong><code>std::sync::Mutex</code> 会阻塞当前线程 (Thread)。</strong></li> <li><strong><code>tokio::sync::Mutex</code> 会让出当前任务 (Task) 的执行权，但不会阻塞线程。</strong></li></ul> <h4 id="行为对比"><a href="#行为对比" class="header-anchor">#</a> 行为对比</h4> <table><thead><tr><th style="text-align:left;">特性</th> <th style="text-align:left;"><code>std::sync::Mutex</code> (标准库锁)</th> <th style="text-align:left;"><code>tokio::sync::Mutex</code> (Tokio 异步锁)</th></tr></thead> <tbody><tr><td style="text-align:left;"><strong>主要用途</strong></td> <td style="text-align:left;">在多<strong>线程 (Thread)</strong> 环境下保护共享数据。</td> <td style="text-align:left;">在多<strong>任务 (Task)</strong> 环境下保护共享数据，专为 <code>async</code> 代码设计。</td></tr> <tr><td style="text-align:left;"><strong>获取锁的方式</strong></td> <td style="text-align:left;"><code>let guard = my_mutex.lock().unwrap();</code></td> <td style="text-align:left;"><code>let guard = my_mutex.lock().await;</code></td></tr> <tr><td style="text-align:left;"><strong>当锁被占用时</strong></td> <td style="text-align:left;"><strong>阻塞当前线程</strong>。操作系统会挂起整个线程，直到锁被释放。线程在此期间无法做任何其他事情。</td> <td style="text-align:left;"><strong>异步地等待</strong>。当前任务返回 <code>Poll::Pending</code>，并被“挂起”。运行时（Tokio）会<strong>切换去执行其他就绪的任务</strong>。当锁被释放时，运行时会唤醒这个任务，让它重新尝试获取锁。</td></tr> <tr><td style="text-align:left;"><strong>对异步运行时的影响</strong></td> <td style="text-align:left;"><strong>灾难性的</strong>。如果在一个异步 worker 线程上使用并发生争用，整个线程都会被冻结。这个线程上成百上千个其他的异步任务都会被卡住，无法取得任何进展。</td> <td style="text-align:left;"><strong>和谐的</strong>。它遵循了异步的“协作式”调度原则。任务只是暂停，线程本身仍然是活跃的，可以继续去处理其他成千上万个任务，最大化了线程的利用率。</td></tr> <tr><td style="text-align:left;"><strong>是否可以跨 <code>.await</code></strong></td> <td style="text-align:left;"><strong>绝对不能</strong>。在持有 <code>std::sync::MutexGuard</code> 的作用域内进行 <code>.await</code> 是非常危险的，极易导致<strong>死锁</strong>。</td> <td style="text-align:left;"><strong>完全可以</strong>。这正是它设计的目的。你可以在获取锁后安全地执行 <code>.await</code> 操作，因为锁的 <code>Guard</code> 是 <code>Send</code> 的。</td></tr></tbody></table> <h4 id="为什么-std-sync-mutex-在异步代码中是危险的"><a href="#为什么-std-sync-mutex-在异步代码中是危险的" class="header-anchor">#</a> 为什么 <code>std::sync::Mutex</code> 在异步代码中是危险的？</h4> <p>假设在一个 Tokio worker 线程上：</p> <ol><li><code>任务1</code> 获取了 <code>std::sync::Mutex</code> 的锁。</li> <li><code>任务1</code> 执行了一个 <code>.await</code> 操作（比如 <code>tokio::time::sleep(..).await</code>），这导致它自己被挂起，并将线程的控制权交还给 Tokio 运行时。</li> <li>Tokio 运行时发现 <code>任务2</code> 已经就绪，于是在同一个线程上开始执行 <code>任务2</code>。</li> <li><code>任务2</code> 也尝试去获取同一个 <code>std::sync::Mutex</code> 的锁。</li> <li>因为这个锁已经被 <code>任务1</code> 持有，所以 <code>任务2</code> 会<strong>阻塞整个线程</strong>。</li> <li>现在，线程被完全阻塞了。这意味着 Tokio 运行时无法再轮询任何任务，包括那个持有锁并且需要被唤醒才能释放锁的 <code>任务1</code>。</li> <li><code>任务1</code> 永远等不到被唤醒，<code>任务2</code> 永远在阻塞等待，死锁发生。</li></ol> <h4 id="何时可以使用-std-sync-mutex"><a href="#何时可以使用-std-sync-mutex" class="header-anchor">#</a> 何时可以使用 <code>std::sync::Mutex</code>？</h4> <p>尽管在 <code>async</code> 函数内部直接使用 <code>std::sync::Mutex</code> 并跨 <code>await</code> 是危险的，但它在某些情况下仍然有用：</p> <ol><li><p><strong>在不包含 <code>.await</code> 的临界区：</strong> 如果你只是想保护一小段纯 CPU 计算的代码，并且确信在这段代码中绝对不会有 <code>.await</code>，那么使用 <code>std::sync::Mutex</code> 是可以的，而且它的性能开销通常比 <code>tokio::sync::Mutex</code> 更低。但为了代码风格的一致性和安全，通常还是推荐使用 <code>tokio</code> 的版本。</p></li> <li><p><strong>在 <code>tokio::task::spawn_blocking</code> 中：</strong> 当你需要与阻塞的、非异步的代码（比如一个传统的数据库驱动）交互时，你会使用 <code>spawn_blocking</code>。在这个闭包内部，你完全处于一个同步的上下文中，因此应该使用 <code>std::sync::Mutex</code> 来和其他同步代码进行交互。</p></li></ol> <h4 id="注意-获取异步锁之后陷入睡眠是不会释放这个锁的"><a href="#注意-获取异步锁之后陷入睡眠是不会释放这个锁的" class="header-anchor">#</a> 注意，获取异步锁之后陷入睡眠是不会释放这个锁的</h4> <p><strong>任务获取 Tokio 的异步锁 (<code>tokio::sync::Mutex</code>) 后，即使 <code>await</code> 陷入睡眠（或者等待 I/O），这个锁仍然是被持有的，不会被释放。</strong></p> <p>这正是 <code>tokio::sync::Mutex</code> 的核心设计目标之一：<strong>允许在持有锁的同时执行异步操作。</strong></p> <p>工作原理：</p> <ol><li><strong>任务 A 尝试获取锁：</strong> <code>let _guard = my_mutex.lock().await;</code></li> <li><strong>获取成功：</strong> <code>_guard</code> 被创建，锁被任务 A 持有。</li> <li><strong>任务 A 执行异步操作：</strong> <code>some_async_op().await;</code> <ul><li>在 <code>await</code> 点，任务 A 会返回 <code>Poll::Pending</code> 给 Tokio 运行时。</li> <li><strong>关键点：</strong> 任务 A 自己被挂起，但它仍然是锁的持有者。这个锁并没有被释放。</li> <li>Tokio 运行时发现任务 A 挂起了，就会转去执行就绪队列中的其他任务（任务 B, C, D 等）。</li> <li>这期间，如果其他任务（比如任务 B）也尝试获取同一个 <code>my_mutex</code> 的锁，它也会遇到锁被持有的情况，然后 <code>lock().await</code> 也会返回 <code>Poll::Pending</code>，任务 B 也会被挂起。</li></ul></li> <li><strong>异步操作完成：</strong> <code>some_async_op()</code> 完成后，Tokio 运行时会唤醒任务 A。</li> <li><strong>任务 A 继续执行：</strong> 任务 A 会从它上次暂停的地方继续执行，<code>_guard</code> 仍然有效。</li> <li><strong>任务 A 完成锁保护的临界区：</strong> 当 <code>_guard</code> 超出作用域时（或者手动 <code>drop</code>），锁才会被释放。</li></ol> <p><strong>但要注意：</strong>
尽管锁在 <code>await</code> 期间不会释放，并且线程不会阻塞，仍然需要警惕持有锁时间过长可能带来的<strong>争用问题</strong>。如果一个任务长时间持有异步锁，其他等待这个锁的任务仍然会长时间处于挂起状态，这会影响程序的并发性能。所以，最佳实践仍然是尽可能地缩短临界区（持有锁的代码块）。</p> <h4 id="为什么-guard-需要实现send-trait"><a href="#为什么-guard-需要实现send-trait" class="header-anchor">#</a> 为什么 guard 需要实现<code>Send</code> trait</h4> <p>当一个任务在一个线程上面执行的时候，他获取了分布锁，并且由于其他的阻塞操作陷入睡眠，但是并没有释放这个锁，后续这个任务可能在其他工作线程上面唤醒继续执行，这就需要这个 guard 可以支持在线程剑传递，因此需要<code>Send</code></p> <h3 id="tokio-的计时器机制"><a href="#tokio-的计时器机制" class="header-anchor">#</a> tokio 的计时器机制</h3> <p>Tokio 的计时器机制是一个非常高效的系统，旨在以最小的开销管理可能存在的成千上万个计时器。它<strong>不会</strong>为每个计时器创建一个线程，也<strong>不会</strong>在一个循环里遍历一个巨大的计时器列表来检查谁到期了。</p> <p>它使用的核心数据结构是<strong>分层时间轮 (Hierarchical Timing Wheel)</strong>。</p> <ul><li><strong>第 1 层（秒轮）：</strong> 一个有 64 个槽（Slot）的轮子。每个槽代表一个时间单位（比如 1 毫秒）。这个轮子能表示接下来的 64 毫秒。</li> <li><strong>第 2 层（分轮）：</strong> 同样有 64 个槽的轮子。当第一层的轮子转完一整圈（64 毫秒）后，第二层的轮子前进一个槽。所以第二层的每个槽代表 64 毫秒。它能表示 <code>64 * 64 = 4096</code> 毫秒。</li> <li><strong>第 3 层（时轮）：</strong> 以此类推，当第二层转完一圈，第三层前进一格。</li></ul> <p><strong>工作流程如下：</strong></p> <ol><li><p><strong>添加计时器 (<code>tokio::time::sleep</code>)</strong></p> <ul><li>当调用 <code>tokio::time::sleep(Duration::from_millis(100))</code> 时，Tokio 运行时会计算出这个计时器应该在未来的哪个时间点被唤醒。</li> <li>它会根据这个时间点，将这个计时器（实际上是关联到这个 <code>sleep</code> 任务的 <code>Waker</code>）放到时间轮上合适的槽里。</li> <li>例如，如果当前时间在第 1 轮的第 5 槽，那么 100 毫秒后应该是在 <code>(5 + 100) % 64 = 41</code>，但因为超过了 64，所以它会被放到第 2 轮的 <code>(100 / 64) = 1</code> 号槽，并记录余数。</li></ul></li> <li><p><strong>计时器驱动 (Timer Driver) 前进</strong></p> <ul><li>Tokio 的运行时有一个内部的“心跳”或“滴答”(tick)。它会定期检查当前时间。</li> <li>它只需要检查<strong>当前时间指针指向的那个槽</strong>。例如，时间前进了 1 毫秒，驱动就将指针从第 1 轮的第 5 槽移动到第 6 槽。</li></ul></li> <li><p><strong>计时器到期</strong></p> <ul><li>当驱动移动到某个槽时，它会检查这个槽里是否存放了计时器。</li> <li>如果槽里有计时器，说明它们已经到期了。</li> <li>驱动会取出这些计时器对应的 <code>Waker</code>，并调用它们的 <code>wake()</code> 方法。</li> <li><code>wake()</code> 方法会通知 Tokio 的调度器：这些任务现在已经就绪，可以放回就绪队列等待执行了。</li></ul></li> <li><p><strong>处理长延时 (Cascading / 级联)</strong></p> <ul><li>如果设置一个很长的 <code>sleep</code>（比如 5 秒），它会被直接放到更高层级的轮子中（比如第 3 层或第 4 层）。</li> <li>当低层级的轮子转完一整圈时，它会检查高一级轮子的下一个槽。如果那个槽里有计时器，它会把这些计时器“重新计算”并“降级”安放到下一层的轮子中。这个过程称为<strong>级联</strong>。</li></ul></li></ol> <p><strong>这种机制的优势：</strong></p> <ul><li><strong>极高的效率 (O(1) 复杂度):</strong> <ul><li><strong>添加计时器</strong>的操作是 O(1) 的，因为它只需要做一次计算就知道该放在哪个槽。</li> <li><strong>检查到期计时器</strong>的操作也是 O(1) 的，因为它只需要看当前时间指针指向的那个槽，完全不需要遍历所有计时器。</li></ul></li> <li><strong>可扩展性强:</strong> 能够以非常低的 CPU 开销同时管理数百万个计时器。</li></ul> <h3 id="tokio-的调度器"><a href="#tokio-的调度器" class="header-anchor">#</a> tokio 的调度器</h3> <p>Tokio 的调度器是其核心的“大脑”，负责决定在哪个线程上、在什么时候、运行哪个异步任务。它的设计目标是<strong>高性能、低延迟和公平性</strong>。</p> <p>Tokio <strong>主要</strong>提供两种调度器类型，你可以通过 <code>#[tokio::main]</code>宏的 <code>flavor</code> 参数来选择：</p> <ol><li><p><strong>多线程调度器 (Multi-Threaded Scheduler): <code>flavor = &quot;multi_thread&quot;</code></strong></p> <ul><li>这是 <strong>默认</strong> 的调度器，也是 Tokio 功能最强大的调度器。当你写 <code>#[tokio::main]</code> 而不加任何参数时，用的就是它。</li> <li><strong>设计目标：</strong> 主要用于需要高并发的网络服务器等场景，旨在最大化利用多核 CPU 的并行处理能力。</li></ul> <p><strong>它的核心工作机制是 “工作窃取” (Work-Stealing)：</strong></p> <ul><li><strong>线程池 (Worker Threads):</strong> 运行时会创建一个线程池，通常线程数量等于机器的 CPU 核心数。每个线程都是一个“工作者 (Worker)”。</li> <li><strong>本地就绪队列 (Per-Worker Local Ready Queue):</strong> 每个工作者线程都有<strong>自己专属</strong>的一个任务队列。当一个任务 A (正在这个工作者上运行) 通过 <code>tokio::spawn</code> 派生出一个新的任务 B 时，任务 B 会被优先放入这个工作者自己的本地队列里。</li> <li><strong>工作流程：</strong> <ol><li>每个工作者线程会优先从自己的<strong>本地队列</strong>的前端取出任务并执行。这非常快，因为<strong>没有</strong>跨线程的锁竞争。</li> <li><strong>“窃取”发生：</strong> 当一个工作者（比如 W1）完成了自己本地队列的所有任务后，它不会闲下来。它随机地选择另一个工作者（比如 W2）从 W2 的本地队列的<strong>尾部</strong>“偷”走一半的任务，放到自己的队列里来执行。</li></ol></li> <li><strong>为什么“偷”尾部的？</strong> <ul><li>工作者自己总是从队列<strong>头部</strong>取任务。</li> <li>小偷从队列<strong>尾部</strong>偷任务。</li> <li>这种“头取尾偷”的模式大大减少了同一个队列两端发生锁竞争的可能性，提高了效率。</li></ul></li> <li><strong>全局注入队列 (Global Injection Queue):</strong> 还有一个全局的任务队列，用于接收从运行时外部（例如，从一个非 Tokio 管理的线程）派生出来的任务。工作者在本地队列为空时，也会尝试从这个全局队列里获取任务。</li></ul></li> <li><p><strong>当前线程调度器 (Current-Thread Scheduler): <code>flavor = &quot;current_thread&quot;</code></strong></p> <ul><li><strong>设计目标：</strong> 用于不需要多线程并行的场景，例如构建客户端应用、嵌入式环境或测试。它的开销更小，因为没有跨线程同步的复杂性。</li> <li><strong>工作机制：</strong> <ul><li>它只在<strong>调用它的那个线程</strong>上运行一个事件循环。</li> <li>所有任务都在这一个线程上被调度和执行。</li> <li>因为它不涉及多线程，所以它内部的数据结构更简单，没有工作窃取的逻辑，性能开销也更低。</li></ul></li></ul></li></ol> <p>所以这个异步运行时更多的是流水的任务，铁打的线程</p> <h4 id="提问-loop-async-op-会不会导致线程池被占用完"><a href="#提问-loop-async-op-会不会导致线程池被占用完" class="header-anchor">#</a> 提问： <code>loop { async_op(); }</code> 会不会导致线程池被占用完？</h4> <p><strong>答案是：它不会导致线程池被“任务”占用完，但它会导致一个 CPU 核心被 100% 占用，从而“饿死”该线程上所有其他的任务，使程序失去响应。</strong></p> <ol><li><p><strong><code>async fn</code> 只是创建了一个 <code>Future</code></strong></p> <ul><li>当定义一个 <code>async fn async_op()</code> 时，实际上是在定义一个函数，这个函数的返回值是一个实现了 <code>Future</code> trait 的<strong>状态机结构体</strong>。</li> <li>调用 <code>async_op()</code> <strong>仅仅是创建了这个结构体的实例</strong>。它<strong>不会</strong>执行函数体内的任何代码。</li></ul></li> <li><p><strong><code>.await</code> 才是执行的驱动力</strong></p> <ul><li>只有当你对一个 <code>Future</code> 使用 <code>.await</code> 时，你才是在告诉 Tokio 的调度器：“请开始执行这个‘计划’，如果它还没准备好（比如在等网络数据），就先暂停它，去做点别的事，等它感兴趣的事件到了在唤醒”</li> <li><code>.await</code> 是一个让出点 (yield point)，它将执行控制权交还给调度器。</li></ul></li></ol> <p><strong>分析代码 <code>loop { async_op(); }</code></strong></p> <ul><li><strong>第一步：</strong> 循环开始，<code>async_op()</code> 被调用。这在内存中创建了一个 <code>Future</code> 对象。</li> <li><strong>第二步：</strong> 这个 <code>Future</code> 对象没有被 <code>await</code>，也没有被 <code>spawn</code>。</li> <li><strong>第三步：</strong> 循环立即进入下一次迭代。在上一次迭代中创建的那个 <code>Future</code> 对象因为超出了作用域，被立即<strong>销毁 (dropped)</strong>。</li> <li><strong>第四步：</strong> 循环回到第一步，不断重复“创建然后立即销毁”这个过程。</li></ul> <p><strong>结论和后果：</strong></p> <ul><li><strong>没有异步操作发生：</strong> <code>async_op</code> 函数体内的任何代码（比如网络请求、文件读写）都<strong>永远不会被执行</strong>，因为它从未 <code>.await</code></li> <li><strong>没有任务提交给线程池：</strong> 没有使用 <code>tokio::spawn</code>，所以没有向 Tokio 的调度器提交任何新的任务。线程池里的任务数量没有增加。</li> <li><strong>主任务阻塞了工作线程：</strong> <code>main</code> 函数本身就是一个异步任务，它运行在 Tokio 的一个工作线程上。 <code>loop</code> 这个循环里没有任何 <code>.await</code>，所以它永远不会把控制权交还给调度器。</li> <li><strong>结果：</strong> 运行 <code>main</code> 任务的那个工作线程会陷入这个无限循环，导致其所在的 <strong>CPU 核心使用率飙升到 100%</strong>。这个线程再也无法去执行调度器分配给它的任何其他任务。</li></ul> <p><strong>note：</strong>
spawn 这个动作本身是非常轻量级的，它基本上就是一次内存分配和一次入队操作。</p> <ul><li>接收一个 Future（也就是一个 async 代码块或 async fn 的返回值）。</li> <li>将这个 Future 包装成一个可执行的单元 Task。</li> <li>将这个 Task 提交给 Tokio 的调度器，让调度器把它放入一个就绪队列中。</li> <li>立即返回一个 JoinHandle，可以用它来等待这个 Task 完成（通过 .await）或中止它。</li></ul> <h4 id="提问-如何决定一个-task-加入哪个线程的调度队列"><a href="#提问-如何决定一个-task-加入哪个线程的调度队列" class="header-anchor">#</a> 提问： 如何决定一个 Task 加入哪个线程的调度队列？</h4> <p>首先，#[tokio::main] 宏会启动 Tokio 运行时，并将 async fn main 函数体作为第一个任务，放到其中一个工作线程（Worker Thread）上去执行。所以，从 async main 函数开始，代码就已经运行在一个 Tokio 的工作线程上了，而不是传统意义上的操作系统“主线程”。</p> <p>spawn 的行为取决于调用 spawn 的代码当前正在哪个线程上运行。
决策逻辑</p> <ul><li><p>场景一（最常见）：在 Tokio 工作线程内部调用 spawn</p> <p>假设 async main 正在工作线程 W1 上运行。
当在 main 函数里调用 tokio::spawn(my_new_task) 时，这个 spawn 调用本身就是在 W1 上执行的。</p> <p>Tokio 的调度器知道当前代码是在 W1 上运行的。因此，它会把 my_new_task 这个新任务放入 W1 自己的本地就绪队列 (Local Ready Queue) 中。</p> <p>将任务放入本地队列完全不需要任何跨线程的锁或同步，速度极快。这最大化了数据的“亲和性”，新创建的任务很可能马上就会被同一个线程执行。（thread_local）</p> <ul><li>嵌套 spawn 的情况
继续上面的例子，假设 W1 后来开始执行 my_new_task。
在 my_new_task 内部，调用 tokio::spawn(another_task)。
此时，spawn 调用仍然是在 W1 上执行的（因为 my_new_task 正在 W1 上运行）。
因此，another_task 也会被放入 W1 的本地队列。</li> <li>工作窃取 (Work-Stealing)
现在，假设 W1 的本地队列里堆积了很多任务（main 剩下的部分, my_new_task, another_task...），而另一个工作线程 W2 已经完成了它自己本地队列的所有任务，现在处于空闲状态。
W2 不会闲着，它会尝试从 W1 本地队列的尾部“偷”走一半的任务，放到它自己的本地队列中。
此时，another_task 可能就被 W2 偷走了。
现在，W2 开始执行 another_task。如果 another_task 内部又调用了 tokio::spawn(final_task)，那么这次 spawn 调用就是在 W2 上执行的，所以 final_task 会被放入 W2 的本地队列。</li></ul></li> <li><p>场景二：在 Tokio 运行时外部调用 spawn</p> <p>这种情况比较少见，但也是存在的。比如有一个由 <code>std::thread::spawn</code> 创建的标准库线程，想从这个线程向 Tokio 运行时提交一个任务。
当从这个外部线程调用 tokio::spawn 时，Tokio 调度器检测到不在任何一个工作线程的上下文里
在这种情况下，新任务会被放入一个全局注入队列 (Global Injection Queue)。
所有工作线程（W1, W2 等）在处理完自己的本地任务后，都会去这个全局队列里检查是否有新任务，并把它们拿到自己的本地队列来执行。</p></li></ul> <h4 id="join-的场景-有助于理解底层的唤醒"><a href="#join-的场景-有助于理解底层的唤醒" class="header-anchor">#</a> join 的场景（有助于理解底层的唤醒）</h4> <p>假设当前任务正在执行这段代码：
<code>let (res1, res2) = tokio::join!(fut1, fut2);</code></p> <ol><li><p><strong>调度器 <code>poll</code> 当前任务</strong></p> <ul><li>调度器决定执行任务。它调用任务的根 <code>Future</code> 的 <code>poll</code> 方法，并传入一个 <code>Context</code>（里面包含了指向这个任务的 <code>Waker</code>）。</li></ul></li> <li><p><strong><code>poll</code> 链式传递</strong></p> <ul><li>这个 <code>poll</code> 调用会沿着 <code>async</code> 代码的逻辑往下走，最终到达 <code>join!</code> 宏生成的那个 <code>JoinFuture</code>。<code>JoinFuture</code> 的 <code>poll</code> 方法被调用，它收到了那个<strong>代表整个任务的 <code>Context</code></strong>。</li></ul></li> <li><p><strong><code>JoinFuture</code> 代理 <code>poll</code></strong></p> <ul><li><code>JoinFuture</code> 的工作是轮询它的子 <code>Future</code>。它首先调用 <code>fut1.poll()</code>，并且将它收到的<strong>同一个 <code>Context</code></strong> 原封不动地传递给 <code>fut1</code>。</li></ul></li> <li><p><strong><code>fut1</code> 无法立即完成</strong></p> <ul><li><code>fut1</code>（比如一个网络请求）发现它现在无法完成。</li> <li>它的关键职责有两个：
<ul><li><strong>A) 注册 <code>Waker</code>：</strong> 它从传递给它的 <code>Context</code> 中取出 <code>Waker</code>。然后它告诉 Tokio 的 I/O 系统：“当这个网络连接上有事件发生时，请调用这个 <code>Waker</code>。”</li> <li><strong>B) 返回 <code>Pending</code>：</strong> 它向它的调用者（也就是 <code>JoinFuture</code>）返回 <code>Poll::Pending</code>。</li></ul></li></ul></li> <li><p><strong><code>JoinFuture</code> 的反应</strong></p> <ul><li><code>JoinFuture</code> 收到 <code>fut1</code> 返回的 <code>Pending</code>。它知道 <code>fut1</code> 还没好。</li> <li>它<strong>不会</strong>停在这里。它会继续去 <code>poll(fut2)</code>（同样传递那个 <code>Context</code>）。</li> <li>假设 <code>fut2</code> 也因为类似的原因返回了 <code>Pending</code>。</li></ul></li> <li><p><strong>任务整体挂起</strong></p> <ul><li>现在 <code>JoinFuture</code> 知道它的所有子 <code>Future</code> 都还没准备好。</li> <li>因此，<code>JoinFuture</code> 自己也向它的调用者（最终是调度器）返回 <code>Poll::Pending</code>。</li> <li>调度器收到 <code>Pending</code> 后，<strong>将当前任务从执行状态移开</strong>，然后去执行其他就绪的任务。<strong>此时，当前任务陷入睡眠，被调度走，但线程本身是活跃的。</strong></li></ul></li> <li><p><strong>外部事件发生</strong></p> <ul><li>一段时间后，<code>fut1</code> 等待的那个网络事件发生了。</li> <li>Tokio 的 I/O 系统被操作系统通知，它找到了之前 <code>fut1</code> 注册的那个 <code>Waker</code>，并调用了 <code>wake()</code> 方法。</li></ul></li> <li><p><strong>任务重回就绪队列</strong></p> <ul><li><code>wake()</code> 的调用，其唯一效果就是<strong>把整个任务重新放回调度器的就绪队列</strong>。</li></ul></li> <li><p><strong>调度器再次 <code>poll</code> 整个任务</strong></p> <ul><li>在未来的某个时间点，调度器从就绪队列中拿出你的任务。</li> <li>它<strong>从头开始</strong>，再次调用任务的根 <code>Future</code> 的 <code>poll</code> 方法，并传入一个新的 <code>Context</code>。</li></ul></li> <li><p><strong>再次执行 <code>JoinFuture</code></strong></p> <ul><li><code>poll</code> 的调用链再次一路向下，最终又一次到达了那个 <code>JoinFuture</code>。</li> <li><code>JoinFuture</code> 再次 <code>poll(fut1)</code>。因为这次网络事件已经发生，<code>fut1</code> 终于可以完成它的工作，并返回 <code>Poll::Ready(result1)</code>。</li> <li><code>JoinFuture</code> 收到 <code>Ready</code>，将 <code>result1</code> 存起来。然后它继续 <code>poll(fut2)</code>。如果 <code>fut2</code> 仍然是 <code>Pending</code>，<code>JoinFuture</code> 就会再次返回 <code>Pending</code>，整个任务再次挂起，等待下一次由 <code>fut2</code> 的事件触发的唤醒。</li></ul></li></ol> <p>这个循环会一直持续，直到 <code>JoinFuture</code> 发现它所有的子 <code>Future</code> 都已经返回了 <code>Ready</code>，它才会最终向调度器返回 <code>Poll::Ready((result1, result2))</code>，任务也才得以从 <code>join!</code> 的 <code>.await</code> 点继续向下执行。</p> <p>//todo 其他的补充</p></div></div> <!----></div> <div class="footer" data-v-3ef679b5><div class="footer-content page" data-v-3ef679b5><div class="left" data-v-3ef679b5><div class="footer-title" data-v-3ef679b5>FRIEND LINKS</div> <div class="links footer-text" data-v-3ef679b5></div> <div class="footer-text" data-v-3ef679b5><span id="busuanzi_container_site_pv" class="footer-count" data-v-3ef679b5><span id="busuanzi_value_site_pv" data-v-3ef679b5></span> <span id="busuanzi_value_site_uv" data-v-3ef679b5></span></span> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>PAGE VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div> <div class="counter" data-v-3ef679b5><div class="counter-title" data-v-3ef679b5>USER VIEWS</div> <div class="counter-content" data-v-3ef679b5><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span><span class="counter-number" data-v-3ef679b5>0</span></div></div></div> </div> <div class="right" data-v-3ef679b5><div class="footer-title power" data-v-3ef679b5>POWERED BY</div> <a href="https://github.com/Yidadaa/Issue-Blog-With-Github-Action" class="logo" data-v-3ef679b5>ISSUE BLOG</a></div></div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a90fafec.js" defer></script><script src="/assets/js/11.a00298db.js" defer></script><script src="/assets/js/4.6f43f24c.js" defer></script><script src="/assets/js/8.ddba2f81.js" defer></script><script src="/assets/js/22.bfacb966.js" defer></script><script src="/assets/js/3.91df9f30.js" defer></script>
  </body>
</html>
