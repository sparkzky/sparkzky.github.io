(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{399:function(t,a,s){"use strict";s.r(a);var r=s(30),v=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"左值和右值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#左值和右值"}},[t._v("#")]),t._v(" 左值和右值")]),t._v(" "),a("h3",{attrs:{id:"简单的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单的定义"}},[t._v("#")]),t._v(" 简单的定义")]),t._v(" "),a("p",[t._v("左值是指占据了内存中某个可识别的位置的对象\n右值则用排除法，不是左值就是右值")]),t._v(" "),a("p",[t._v("比如")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int var = 4;\n")])])]),a("p",[t._v("这里的 var 就是一个左值，而 4 就是一个右值，因为它是表达式的临时结果，而没有可识别的内存位置（也就是说，只存在于计算过程中的每个临时寄存器中）")]),t._v(" "),a("h3",{attrs:{id:"不可修改的左值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不可修改的左值"}},[t._v("#")]),t._v(" 不可修改的左值")]),t._v(" "),a("p",[a("code",[t._v("const int a = 4;")])]),t._v(" "),a("p",[t._v("这个时候 a 就不可以被赋值，不属于可修改左值")]),t._v(" "),a("p",[t._v("可修改左值是特殊的左值，不含有数组类型、不完整类型、const 修饰的类型。如果它是 struct 或 union，它的成员都（递归地）不应含有 const 修饰的类型。")]),t._v(" "),a("h3",{attrs:{id:"左值和右值的转换"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#左值和右值的转换"}},[t._v("#")]),t._v(" 左值和右值的转换")]),t._v(" "),a("div",{staticClass:"language-int a = 1; extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("int b = 1;\nint c = a + b;\n")])])]),a("p",[t._v("这个时候原本 a 和 b 都属于左值，但由于+完成的是对右值的计算，则这里会被隐式地转换成右值，但右值并不会隐式的转换成左值")]),t._v(" "),a("p",[t._v("不过还有显式的完成对左值和右值的转换的方法")]),t._v(" "),a("p",[a("code",[t._v("*")]),t._v("：接受一个右值，转换成左值")]),t._v(" "),a("p",[a("code",[t._v("&")]),t._v("：接受一个左值，转换成右值")]),t._v(" "),a("h3",{attrs:{id:"左值引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#左值引用"}},[t._v("#")]),t._v(" 左值引用")]),t._v(" "),a("p",[a("code",[t._v("string & ref = string()")]),t._v("\n不能将一个右值赋值给一个（非常量的）左值引用\n但是常量的左值引用可以使用右值赋值，因为无法通过常量的引用去修改变量的值，也就不会出现修改了右值的情况")]),t._v(" "),a("h3",{attrs:{id:"右值引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#右值引用"}},[t._v("#")]),t._v(" 右值引用")]),t._v(" "),a("p",[t._v("避免临时对象的产生，实现移动语义。\n调用结束后，右值引用会被销毁，因此可以直接复用右值的内部内容，因为它不会再被使用")]),t._v(" "),a("p",[t._v("（之前写的，现迁移过来）")])])}),[],!1,null,null,null);a.default=v.exports}}]);